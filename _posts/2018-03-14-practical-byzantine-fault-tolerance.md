---
title: 拜占庭将军问题与PBFT算法
categories:
 - 区块链
tags:
 - 区块链
---

### 1 拜占庭将军问题
Leslie Lamport(莱斯利·兰波特)在论文《The Byzantine Generals Problem》提出拜占庭将军问题：
> 一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。


出现的问题：

1. 假如有5支部队，低于3支部队则无法攻打下来反而会被反攻，有2支部队选择进攻，2支选择撤退，这时候出现一个叛徒，对其中2支选择进攻的部队送信说要进攻，选择进攻的部队一看有3支部队选进攻则进攻；叛徒对2支选择撤退的部队送信说要撤退，选择撤退的部队一看有3支部队选撤退则撤退了，最终3支部队攻城失败，整个部队失败。一致性遭到破坏。
2. 也可能送信的过程中，送信人被敌人截杀，部队一直不能收到所有其他部队传递过来的消息。

### 2 分布式计算机系统
以上问题放到计算机系统中，各支部队便是计算机，信差便是通信系统。

### 3 PBFT（Practical Byzantine Fault Tolerance）实用拜占庭容错
PBFT算法的核心理论是N>=3F+1，其中N是总节点数，F是故障节点（故障包括叛徒或不响应）。假如有F个故障节点，至少有3F+1个节点才能保证整个系统正确运行。

算法要求至少要4个参与者ABCD，1个为总司令，3个师长

没有叛徒：

1. 4个将军分别为ABCD，选举A为总司令，总统（终端用户）向A说进攻
2. A对BCD说进攻
3. BCD都各自对其他节点说进攻
4. 每个节点都收到其他人说进攻的指令，则进攻


假如出现1个叛徒D：

1. A对BCD说进攻
2. D对BC说撤退
3. 对B而言，A和C说进攻（2票）大于D说撤退（1票），进攻


假如出现2个叛徒CD：

1. A对BCD说进攻
2. CD对B说撤退，撤退
3. A又进攻，一致性失败


所以当有4个节点时，只能容许1个节点出问题，该问题可能是叛徒（伪造消息）或者没有消息（无响应）


实际上PBFT会更复杂一些，分为预准备（pre-prepare）、准备(prepare)和确认(commit)

![图片](https://github.com/funson86/funson86.github.io/blob/master/_posts/image/pbft.png?raw=true)

1. request：总统C向1发消息
2. pre-prepare：服务端0收到C的请求后进行广播，扩散至123
3. prepare：123,收到后记录并再次广播，1->023，2->013，3因为宕机无法广播
4. commit:0123节点在Prepare阶段，若收到2F（F为可容忍错误个数）个或以上和自己相同的请求，则进入Commit阶段，广播Commit请求
5. reply：0123节点在Commit阶段，若收到2F+1个的相同请求，则对C进行反馈

加入出现1个伪装节点3，对于1号节点来说，有0、2号节点和自己相同，大于等于2F个即2个，则进入commit阶段，并告知其他节点；同理对于0号节点和2号节点也会进入commit阶段。最终有0、1、2三个节点进入commit阶段，3个请求满足2F+1个即3个，它们会对C进行反馈。

&nbsp;

- 为什么是3F+1

容错，就是不需要等待的数量，当有4个节点，只需要有3个节点反馈数据就立即决策了，那么3个有可能是一个是有伪装的，这种情况下也能保证系统一致性（节点不能无限制的等待所有其他节点都发数据过来，他只需要等待N-F即2F+1个反馈）。 
2. 如果未接到反馈的恰好是叛徒节点，剩下的全都保持一致，没有问题。
3. 如果未反馈的是好节点，叛徒节点只有1票，则2个好节点>1个叛徒，系统正常。
4. 3F+1。系统只等N-F个就做决策。极端情况下，所有的F个叛徒都先发数据，那么剩下的必须必须是F+1个正确的节点才能保证 F+1个叛徒 > F个叛徒，那么所有N的节点为（F+1个收到的节点 + F个未收到节点 + F个叛徒）也就是3F+1个。
