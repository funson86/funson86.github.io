---
title: RSA公钥私钥加密算法
categories:
 - 区块链
tags:
 - 区块链
---

## 1 数论
1. 一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。质数如2、3、5、7
2. 每一个合数都可以以唯一形式被写成质数的乘积，即分解质因数。
3. 对于大数而言，目前来说没有很好的分解质因数方法，一般而言，计算机从2开始一个个测试来判断是否为质因数。
4. 欧拉函数O(n)是小于或等于n的正整数中与n互质的数的数目。
5. 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。比如a=3，n=11;则b=4。实际上4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即b+kn都是a的模反元素
5. 欧拉定理：即a的O(n)次方与1在模n下同余；O(n)为欧拉函数。如上n=11，O(n)=10，a的O(n)次方为3的10次方等于=59049=（5368*11 + 1）。（同余：两个整数a，b，若它们除以正整数m所得的余数相等，则称a， b对于模m同余，如26等于14(mod12)）


## 2 RSA算法
RSA加密算法是一种非对称加密技术，即加密时候用的密钥（公钥）和解密时用的密钥（私钥）不是同一把。

基本原理是将两个很大的质数相乘很容易得到乘积，但是该乘积分解质因数却很困难。

也就是说对就计算机来说997210243分解质因数很困难，只能从2、3、5一个个测试。而计算9973 * 99991 = 997210243却很容易。

## 3 公钥与私钥的产生
1. 随意选择两个大质数p和q，p不等于q，计算出N=p*q
2. 根据欧拉函数，任何质数p的互质数目为p-1，另r=O(N)=O(p)*O(q)=(p-1)*(q-1)
3. 选择一个小于r的整数e，另r和e互质，求e关于r的模反元素为d。
4. 将p和q的记录消除
5. (N, e)为公钥；（N，d）为私钥。

如p=11, q=2; 则N=22, r=10。 选择e=3, d可以为7,17,27（7+10k）

公钥为(22, 3)， 私钥为(22, 7)

## 4 加密消息
原始信息为n，加密动作为：

c = n的e次方 (mod N) 

如上例，原始数据6，6的3次方为216， (mod 22) 后为18

注：原始数据n必须小于N，当p和q足够大的时候是没问题的

## 5 解密消息
现在要通过c和私钥(N,d)将c解密出n。

c的d次方 = n （mod N）

如上例 18的7次方=612220032，(mod 22)后为6； 18的17次方2185911559738696531968，(mod 22)后22也为6

![图片](https://github.com/funson86/funson86.github.io/blob/master/_posts/image/rsa_decrypt.png?raw=true)


## 6 安全性
假设偷听者乙获得了甲的公钥N和e以及丙的加密消息c，但她无法直接获得甲的密钥d。

根据公式 e*d = 1 (mod (p-1)(q-1))，那么最简单的方式就是分解N的质因数p和q。

但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在。


## 7 参考
维基百科：[质因数分解](https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3)

维基百科：[模反元素](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0)

维基百科：[欧拉函数](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)

维基百科：[欧拉定理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))

维基百科：[RSA加密解密算法](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)
 

[HTTPS 原理解析](https://www.cnblogs.com/zery/p/5164795.html)

[https流程图](https://processon.com/view/5667d245e4b07d6b0c1e1e91)

## 8 数字签名
由于公钥和私钥不同，甲方将公钥发给乙方，然后将明文进行hash算法得到摘要Digest1，并对摘要使用私钥得到签名。明文和签名都发给乙方，乙方对明文进行hash算法得到摘要Digest再用公钥解密得到Digest2，如果Digest1和Digest2相同则确定为甲方发的。

## 9 数字证书(Certificate Authority)
上一步骤，甲方怎么得到公钥呢？万一有人伪造甲方给一个公钥，然后用伪造的私钥加密给乙方，这样乙方就会被欺骗。

数字证书简称(Certificate Authority)，由权威机构给甲方（服务器）颁发的一种认可凭证。


## 10 ssl与https
SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。

HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。

![图片](https://github.com/funson86/funson86.github.io/blob/master/_posts/image/rsa_https.png?raw=true)

1. 客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端
2.  服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法。以证书的形式返回给客户端 证书中还包含了 公钥 颁证机构 网址 失效日期等等。
3. 客户端收到服务端响应后会做以下几件事

    - 3.1 验证证书的合法性  
    颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等。证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)

    - 3.2 生成随机密码  
    如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 　　　　　　

    - 3.3 HASH握手信息  
    用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端  
    在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。


4. 服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端


5.  客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。

